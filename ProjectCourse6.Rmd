---
title: "ProjectCourse6"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown
Dit is een R Markdown document voor het project van course 6 gemaakt door groep 1. blablabla (╯°□°）╯︵ ┻━┻

```{r packagesLaden, include = FALSE}
require(edgeR)
require(limma)
require(stats)
require(dplyr)
require(ggplot2)
require(ggfortify)
require(dendextend)
require(gtools)
```
```{r include = FALSE}
# Data RNA-seq inlezen en annotatie eraan koppelen. 
setwd(dirname(rstudioapi::getSourceEditorContext()$path))

inhoud = read.table("./RNAseq-bestanden/RNA-Seq-counts.txt", header=TRUE)
row.names(inhoud) = inhoud[,"ID"]
annotatie = read.table("./RNAseq-bestanden/WCFS1_anno.txt", header=TRUE, sep="\t"
                  , quote="")
names(annotatie)[names(annotatie) == "name"] = "ID"
data = merge(inhoud, annotatie, by="ID")

group <- factor(c("WCFS1.glc",	"WCFS1.glc",	"WCFS1.rib"
                 , "WCFS1.rib", "NC8.glc", "NC8.glc"	
                 , "NC8.rib", "NC8.rib"))
x <- DGEList(counts=data[,2:9], group=group)

# Normalisatiefactoren berekenen en low-read-counts wegfilteren,
# nodig voor normalisatie en dispersie.
x <- calcNormFactors(x, method="TMM" )
keep <- filterByExpr(x)
x <- x[keep, , keep.lib.sizes=FALSE]
x$samples$lib.size = colSums(x$counts)

# Design matrix maken, nodig voor dispersie bepalen.
design <- model.matrix(~0+group, data=x$samples)
colnames(design) <- levels(x$samples$group)

# Dispersie bepalen.
x <- estimateGLMCommonDisp(x,design)
x <- estimateGLMTrendedDisp(x,design, method="power")
x <- estimateGLMTagwiseDisp(x,design)
```

### Samenvatting van genormaliseerde data
Overzicht van alle counts:
```{r samenvattingCounts, echo=FALSE}
print(summary(x$counts))
```
Overzicht van de verschillende groepen:
```{r samplesPrinten, echo=FALSE}
print(x$samples)
```
### Plots van genormaliseerde data
```{r plotsWeergeven, echo=FALSE}
plotMDS(x)
plotBCV(x)
```

### Fit data
```{r}
fit <- glmFit(x,design)
fit$counts
```

### P-waarde berekenen
```{r}
mc <- makeContrasts(exp.r=WCFS1.glc-WCFS1.rib, levels=design)
fit <- glmLRT(fit, contrast=mc)
```
### Print top tags
```{r}
res<-topTags(fit)
print(res)
```
### Correlatie van de data
```{r}
cor.test(x$counts[,1], x$counts[,2])
cor.test(x$counts[,3], x$counts[,4])
```
### Alle p-values
```{r}
PV <- fit[["table"]][["PValue"]]
head(PV, 100)
```
### Grafiek om het aantal clusters te laten zien
```{r}
# wordt gebruikt om het aantal cluster weer te geven dat je moet gebruiken voor de K-means
wssplot <- function(data, nc=15, seed=1234)
{
  wss <- (nrow(data)-1)*sum(apply(data, 2,var))
  for (i in 2:nc){
    set.seed(seed)
    wss[i] <- sum(kmeans(data, centers=i)$withinss)}
  plot(1:nc, wss, type='b', xlab = "number of clusters", 
       ylab = "within groups sum of squares")
}
# Bij de waarde waar hij overloopt tot een rechte lijn moet je gebruiken voor aantal clusters.
# Dus met deze gegevens wordt een cluster van 4 gebruikt
mydata = select(data, c(2,3,4,5,6,7,8,9))
wssplot(mydata)
```



### K-means berekenen.
```{r}
KM = kmeans(mydata, 4)
autoplot(KM, mydata, frame=TRUE)
```

### Foldchange berekeningen
```{r}
<<<<<<< HEAD
meanWCFSglu <- rowMeans(mydata[,1:2])

meanWCFSrib <-rowMeans(mydata[,3:4])

meanNC8glu <-rowMeans(mydata[,5:6])

meanNC8rib <-rowMeans(mydata[,7:8])

=======
aggregate(mydata,by=list(KM$cluster),FUN=mean)
# append cluster assignment
mydata <- data.frame(mydata, KM$cluster)
#mydata
```

### FoldChange
```{r}

<<<<<<< HEAD
=======
#df=data.frame(group=rep(c("A","B"),5), value1=1:10,value2=21:30,value3=41:50,stringsAsFactors = F)
#df
<<<<<<< HEAD
=======

>>>>>>> ed2601102043b39e87445cc71fcc75dffbdf9ad6
mydata
# Deze berekining is goed!!
meanWCFSglu <- rowMeans(mydata[,1:2])
meanWCFSrib <-rowMeans(mydata[,3:4])
meanNC8glu <-rowMeans(mydata[,5:6])
meanNC8rib <-rowMeans(mydata[,7:8])
>>>>>>> 1aca34a9a4d1f1a7e3061220664a0e41982cf4c3
# vergelijk hier de gemiddelden van de experimenten met elkaar
# vergelijk dus WCFS.glc met WCFS.rib

# bereken de foldchange tussen twee kolommen
WCFSfc <- foldchange(meanWCFSglu , meanWCFSrib )
test <- table[(WCFSfc > 2)]
test
NC8fc <- foldchange(meanNC8glu , meanNC8rib )

my_list <- list(WCFSfc, NC8fc)

FoldchangeFrame <- data.frame(do.call(cbind, my_list))
FoldchangeFrame
#maak de FC Log2

WCFSfclog <- foldchange2logratio(WCFSfc, base=2)

NC8fclog <- foldchange2logratio(NC8fc, base=2)

my_list2 <- list(WCFSfclog, NC8fclog)

as.data.frame(do.call(cbind, my_list2))
```

### Hierachisch clusteren
```{r}
c_data = t(x$counts)
dist = dist(c_data, method = "euclidean")
# Het clustogram wordt gevormd en geplot
hclust = hclust(dist)
plot(hclust)
```