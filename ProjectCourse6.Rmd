---
title: "ProjectCourse6"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

Dit is een R Markdown document voor het project van course 6 gemaakt door groep 1. blablabla

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:


```{r include = FALSE}
library(edgeR)
require(limma)
library(stats)
library(dplyr)
library(ggplot2)
library(ggfortify)
library(dendextend)
library(gtools)
```
### Huidige werkmap instellen naar map waar script in staat. 
```{r}
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
```
### read counts
```{r}

inhoud = read.table("./RNAseq-bestanden/RNA-Seq-counts.txt", header=TRUE)
row.names(inhoud) = inhoud[,"ID"]
annotatie = read.table("./RNAseq-bestanden/WCFS1_anno.txt", header=TRUE, sep="\t"
                  , quote="")
names(annotatie)[names(annotatie) == "name"] = "ID"
data = merge(inhoud, annotatie, by="ID")
```

### Create DGEList
```{r}
#exp <- c("WCFS1.glc","WCFS1.glc","WCFS1.rib","WCFS1.rib")

group <- factor(c("WCFS1.glc",	"WCFS1.glc",	"WCFS1.rib"
                 , "WCFS1.rib", "NC8.glc", "NC8.glc"	
                 , "NC8.rib", "NC8.rib"))
x <- DGEList(counts=data[,2:9], group=group)
```

### Normalise counts
### Trimmed mean of M values : remove lowest and highest values
### (percentile) and calculate mean
```{r}
x <- calcNormFactors(x, method="TMM" )
keep <- filterByExpr(x)
x <- x[keep, , keep.lib.sizes=FALSE]
x$samples$lib.size = colSums(x$counts)
```

### Check statistics
```{r}
#print("Count statistics")
#print(summary(x$counts))
#print(x$samples)
```

### Create design matrix
```{r}
design <- model.matrix(~0+group, data=x$samples)
colnames(design) <- levels(x$samples$group)
```

### Estimate Dispersion
```{r}
x <- estimateGLMCommonDisp(x,design)
x <- estimateGLMTrendedDisp(x,design, method="power")
x <- estimateGLMTagwiseDisp(x,design)
```

### Plot results
```{r}
pdf(paste0("test.pdf"))
plotMDS(x)
plotBCV(x)
dev.off()
```

### Fit data
```{r}
fit <- glmFit(x,design)
```

### P-waarde berekenen
```{r}
mc <- makeContrasts(exp.r=WCFS1.glc-WCFS1.rib, levels=design)

fit <- glmLRT(fit, contrast=mc)
```
### Print top tags
```{r}
res<-topTags(fit)
print(res)
```
### Correlatie van de data
```{r}
cor.test(x$counts[,1], x$counts[,2])
cor.test(x$counts[,3], x$counts[,4])
```
### Alle p-values
```{r}
PV <- fit[["table"]][["PValue"]]
head(PV, 100)
```

```{r}
wssplot <- function(data, nc=15, seed=1234)
{
  wss <- (nrow(data)-1)*sum(apply(data, 2,var))
  for (i in 2:nc){
    set.seed(seed)
    wss[i] <- sum(kmeans(data, centers=i)$withinss)}
  plot(1:nc, wss, type='b', xlab = "number of clusters", 
       ylab = "within groups sum of squares")
}

mydata = select(data, c(2,3,4,5,6,7,8,9))
wssplot(mydata)
```



###K-means berekenen.
```{r}
KM = kmeans(mydata, 4)
autoplot(KM, mydata, frame=TRUE)
```

###BingBong
```{r}
aggregate(mydata,by=list(KM$cluster),FUN=mean)
# append cluster assignment
mydata <- data.frame(mydata, KM$cluster)
mydata
```
```{r}
#install.packages('dendextend')
```

### testje met Foldchange
```{r}

#df=data.frame(group=rep(c("A","B"),5), value1=1:10,value2=21:30,value3=41:50,stringsAsFactors = F)
#df

mydata
# Deze berekining is goed!!
meanWCFSglu <- rowMeans(mydata[,1:2])
meanWCFSglu

meanWCFSrib <-rowMeans(mydata[,3:4])
meanWCFSrib

meanNC8glu <-rowMeans(mydata[,5:6])
meanNC8glu

meanNC8rib <-rowMeans(mydata[,7:8])
meanNC8rib
# vergelijk hier de gemiddelden van de experimenten met elkaar
# vergelijk dus WCFS.glc met WCFS.rib

# bereken de foldchange tussen twee kolommen
WCFSfc <- foldchange(meanWCFSglu , meanWCFSrib )
NC8fc <- foldchange(meanNC8glu , meanNC8rib )

my_list <- list(WCFSfc, NC8fc)
my_list

as.data.frame(do.call(cbind, my_list))
#maak de FC Log2
WCFSfc
NC8fc

WCFSfclog <- foldchange2logratio(WCFSfc, base=2)
WCFSfclog

NC8fclog <- foldchange2logratio(NC8fc, base=2)
NC8fclog

my_list2 <- list(WCFSfclog, NC8fclog)
my_list2

as.data.frame(do.call(cbind, my_list2))



```

###Hierachisch clusteren
```{r}
dend <- mydata[1:8,] %>% scale %>%
  dist %>% hclust %>% as.dendrogram
dend %>% set("labels", c("WCFS1.glc.2", "NC8.glc.1", "NC8.rib.2", "WCFS1.rib.1", "WCFS1.rib.2", "NC8.rib.1", "WCFS1.glc.1", "NC8.glc.1")) %>% plot
```

```{r}
View(data)
?hclust
```