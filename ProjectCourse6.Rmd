---
title: "ProjectCourse6"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown
Dit is een R Markdown document voor het project van course 6 gemaakt door groep 1. blablabla (╯°□°）╯︵ ┻━┻
 

```{r packagesLaden, include = FALSE}
require(edgeR)
require(limma)
require(stats)
require(dplyr)
require(ggplot2)
require(ggfortify)
require(dendextend)
require(gtools)
```

```{r include = FALSE}
# Data RNA-seq inlezen en annotatie eraan koppelen. 
setwd(dirname(rstudioapi::getSourceEditorContext()$path))

inhoud = read.table("./RNAseq-bestanden/RNA-Seq-counts.txt", header=TRUE)
row.names(inhoud) = inhoud[,"ID"]
annotatie = read.table("./RNAseq-bestanden/WCFS1_anno.txt", header=TRUE, sep="\t"
                  , quote="")
names(annotatie)[names(annotatie) == "name"] = "ID"
data = merge(inhoud, annotatie, by="ID")

group <- factor(c("WCFS1.glc",	"WCFS1.glc",	"WCFS1.rib"
                 , "WCFS1.rib", "NC8.glc", "NC8.glc"	
                 , "NC8.rib", "NC8.rib"))
x <- DGEList(counts=data[,2:9], group=group)

# Normalisatiefactoren berekenen en low-read-counts wegfilteren,
# nodig voor normalisatie en dispersie.
x <- calcNormFactors(x, method="TMM" )
keep <- filterByExpr(x)
x <- x[keep, , keep.lib.sizes=FALSE]
x$samples$lib.size = colSums(x$counts)

# Design matrix maken, nodig voor dispersie bepalen.
design <- model.matrix(~0+group, data=x$samples)
colnames(design) <- levels(x$samples$group)

# Dispersie bepalen.
x <- estimateGLMCommonDisp(x,design)
x <- estimateGLMTrendedDisp(x,design, method="power")
x <- estimateGLMTagwiseDisp(x,design)
```

### Samenvatting van genormaliseerde data
Overzicht van alle counts:
```{r samenvattingCounts, echo=FALSE}
print(summary(x$counts))
```
Overzicht van de verschillende groepen:
```{r samplesPrinten, echo=FALSE}
print(x$samples)
```
### Plots van genormaliseerde data
```{r plotsWeergeven, echo=FALSE}
plotMDS(x)
plotBCV(x)
```












### Fit data
```{r}
fit <- glmFit(x,design)
```

### P-waarde berekenen
```{r}
mc <- makeContrasts(exp.r=WCFS1.glc-WCFS1.rib, levels=design)

fit <- glmLRT(fit, contrast=mc)
```
### Print top tags
```{r}
res<-topTags(fit)
print(res)
```
### Correlatie van de data
```{r}
cor.test(x$counts[,1], x$counts[,2])
cor.test(x$counts[,3], x$counts[,4])
```
### Alle p-values
```{r}
PV <- fit[["table"]][["PValue"]]
head(PV, 100)
```

```{r}
wssplot <- function(data, nc=15, seed=1234)
{
  wss <- (nrow(data)-1)*sum(apply(data, 2,var))
  for (i in 2:nc){
    set.seed(seed)
    wss[i] <- sum(kmeans(data, centers=i)$withinss)}
  plot(1:nc, wss, type='b', xlab = "number of clusters", 
       ylab = "within groups sum of squares")
}

mydata = select(data, c(2,3,4,5,6,7,8,9))
wssplot(mydata)
```



###K-means berekenen.
```{r}
KM = kmeans(mydata, 4)
autoplot(KM, mydata, frame=TRUE)
```

###BingBong
```{r}
aggregate(mydata,by=list(KM$cluster),FUN=mean)
# append cluster assignment
mydata <- data.frame(mydata, KM$cluster)
#mydata
```
```{r}
#install.packages('dendextend')
```

### testje met Foldchange
```{r}

#df=data.frame(group=rep(c("A","B"),5), value1=1:10,value2=21:30,value3=41:50,stringsAsFactors = F)
#df

mydata
# Deze berekining is goed!!
meanWCFSglu <- rowMeans(mydata[,1:2])
meanWCFSglu

meanWCFSrib <-rowMeans(mydata[,3:4])
meanWCFSrib

meanNC8glu <-rowMeans(mydata[,5:6])
meanNC8glu

meanNC8rib <-rowMeans(mydata[,7:8])
meanNC8rib
# vergelijk hier de gemiddelden van de experimenten met elkaar
# vergelijk dus WCFS.glc met WCFS.rib

# bereken de foldchange tussen twee kolommen
WCFSfc <- foldchange(meanWCFSglu , meanWCFSrib )
NC8fc <- foldchange(meanNC8glu , meanNC8rib )

my_list <- list(WCFSfc, NC8fc)
my_list

as.data.frame(do.call(cbind, my_list))
#maak de FC Log2
WCFSfc
NC8fc

#res=aggregate(.~group,mydata,mean) 
#res["fc",]=c("glc.vs.rib",as.numeric(res[1,-1])/as.numeric(res[2,-1]))
#res
WCFSfclog <- foldchange2logratio(WCFSfc, base=2)
WCFSfclog

NC8fclog <- foldchange2logratio(NC8fc, base=2)
NC8fclog

my_list2 <- list(WCFSfclog, NC8fclog)
my_list2

as.data.frame(do.call(cbind, my_list2))
```

###Hierachisch clusteren
```{r}
# code Karsten
c_data = t(x$counts)
dist = dist(c_data, method = "euclidean")
# Het clustogram wordt gevormd en geplot
hclust = hclust(dist)
plot(hclust)

#code karsten



#dend <- mydata[1:8,] %>% scale %>%
  #dist %>% hclust %>% as.dendrogram
#dend %>% set("labels", c("WCFS1.glc.2", "NC8.glc.1", "NC8.rib.2", "WCFS1.rib.1", "WCFS1.rib.2", "NC8.rib.1", "WCFS1.glc.1", "NC8.glc.1")) %>% plot

#dend %>% set("labels", c("WCFS1.glc.1", "WCFS.glc.2", "WCFS.rib.1", "WCFS1.rib.2", "NC8.glu.1", "NC8.glu.2", "NC8.rib.1", "NC8.rib.2")) %>% plot
```

```{r}
#View(data)
#?hclust
```